<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Urban Lockdown: Web FPS</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden; background: #222;
      font-family: 'Segoe UI', Arial, sans-serif;
    }
    #menu {
      position: absolute;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: linear-gradient(135deg, #222 70%, #444 100%);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      z-index: 10;
    }
    #title {
      font-size: 3em; color: #eee; letter-spacing: 2px;
      text-shadow: 2px 2px 12px #111, 0 0 20px #07f;
      margin-bottom: 0.5em;
      font-weight: bold;
    }
    #subtitle {
      color: #95c8f8; font-size: 1.2em; margin-bottom: 2em;
      text-shadow: 1px 1px 8px #111;
    }
    #startBtn, #restartBtn {
      padding: 1em 2.5em; font-size: 1.3em; background: #07f;
      color: #fff; border: none; border-radius: 7px;
      box-shadow: 0 6px 22px #07f7;
      transition: 0.2s; cursor: pointer; margin-bottom: 1.5em;
      font-weight: bold;
    }
    #startBtn:hover, #restartBtn:hover { background: #005be1; }
    #info, #gameover {
      color: #fff; text-align: center; margin-top: 2em;
      font-size: 1.1em;
    }
    #hud {
      position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
      pointer-events: none; z-index: 8;
      display: flex; flex-direction: column; justify-content: flex-end;
    }
    #crosshair {
      position: absolute; left: 50%; top: 50%;
      width: 30px; height: 30px; transform: translate(-50%, -50%);
      z-index: 20; pointer-events: none;
    }
    #crosshair:after {
      content: '';
      position: absolute; left: 14px; top: 0; width: 2px; height: 30px; background: #fff;
      opacity: 0.7;
    }
    #crosshair:before {
      content: '';
      position: absolute; top: 14px; left: 0; height: 2px; width: 30px; background: #fff;
      opacity: 0.7;
    }
    #hudText {
      color: #eee; font-size: 1.1em; margin: 0.7em 1em; text-shadow: 1px 1px 4px #000;
      background: rgba(0,0,0,0.2); border-radius: 9px; padding: 0.5em 1.2em; align-self: flex-start;
      user-select: none;
    }
    #ammo {
      color: #fffb; font-size: 1.35em; font-weight: bold;
      position: absolute; right: 1.5em; bottom: 1.5em;
      background: rgba(0,0,0,0.4); padding: 0.4em 1em; border-radius: 1em;
      text-shadow: 1px 1px 4px #000;
      user-select: none;
    }
    #damageFlash {
      pointer-events: none;
      position: absolute; top:0; left:0; width: 100vw; height: 100vh;
      background: rgba(255,0,0,0.14); display: none; z-index: 99;
    }
    #pickup {
      position: absolute; left: 50%; top: 60%; transform: translate(-50%, -50%);
      color: #ff8; background: rgba(0,0,0,0.45); border-radius: 6px;
      padding: 0.6em 1.6em; font-size: 1.1em; z-index: 30; display: none;
      text-shadow: 1px 1px 4px #000;
    }
    #mobile {
      display: none;
      position: absolute; left: 0; top: 0; width: 100vw; height: 100vh;
      background: #111f; z-index: 99; color: #fff; font-size: 2em;
      align-items: center; justify-content: center;
    }
    @media (max-width: 900px) {
      #mobile { display: flex; }
    }
  </style>
</head>
<body>
  <div id="menu">
    <div id="title">Urban Lockdown: Web FPS</div>
    <div id="subtitle">Fight for your life in a city under siege.<br>
      WASD: Move &nbsp;|&nbsp; Mouse: Look/Shoot &nbsp;|&nbsp; R: Reload</div>
    <button id="startBtn">Start Game</button>
    <div id="info">Best played with keyboard & mouse.<br>
      Press <b>ESC</b> any time to unlock the mouse.<br>
      <br>Made with <span style="color:#07f;">Three.js</span>
    </div>
  </div>
  <div id="mobile">Please use a desktop/laptop for the best FPS experience!</div>
  <div id="hud" style="display:none;">
    <div id="hudText"></div>
    <div id="ammo"></div>
    <div id="crosshair"></div>
    <div id="pickup"></div>
    <div id="damageFlash"></div>
  </div>
  <div id="gameover" style="display:none;"></div>

  <!-- THREE.JS and PointerLockControls as ES Modules -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';
    import { PointerLockControls } from 'https://unpkg.com/three@0.154.0/examples/jsm/controls/PointerLockControls.js';

    // --- GLOBALS ---
    let renderer, scene, camera, controls, clock;
    let player = {
      pos: new THREE.Vector3(0, 2, 0),
      vel: new THREE.Vector3(),
      dir: new THREE.Vector3(),
      health: 100,
      maxHealth: 100,
      ammo: 30,
      mag: 30,
      reserve: 90,
      reloading: false,
      reloadTime: 1.3,
      lastShot: 0,
      score: 0,
      alive: true
    };
    let keys = {}, mouseDown = false, pointerLocked = false;
    let enemies = [], pickups = [];
    let nextEnemySpawn = 0, enemyCount = 0, level = 1;
    let objects = [];
    let reloadTimer = 0;
    let pickupMsgTimer = 0;
    let lastDamageTime = 0;

    // DOM
    const menu = document.getElementById('menu'),
          hud = document.getElementById('hud'),
          hudText = document.getElementById('hudText'),
          ammo = document.getElementById('ammo'),
          crosshair = document.getElementById('crosshair'),
          pickupMsg = document.getElementById('pickup'),
          damageFlash = document.getElementById('damageFlash'),
          gameover = document.getElementById('gameover'),
          mobile = document.getElementById('mobile'),
          startBtn = document.getElementById('startBtn');

    // --- INIT ---
    function setup() {
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setClearColor(0x222233);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 250);
      camera.position.set(0, 2, 6);

      // Lighting
      const ambLight = new THREE.AmbientLight(0x9999b0, 0.5);
      scene.add(ambLight);
      let hemiLight = new THREE.HemisphereLight(0xeeeeff, 0x444466, 0.5);
      scene.add(hemiLight);

      // Main directional light (sun)
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.65);
      dirLight.position.set(-13, 18, 6);
      dirLight.castShadow = false;
      scene.add(dirLight);

      // Controls
      controls = new PointerLockControls(camera, renderer.domElement);
      controls.getObject().position.set(0,2,0);

      // Floor
      const floorGeo = new THREE.PlaneGeometry(80, 80);
      const floorMat = new THREE.MeshPhongMaterial({color:0x335, shininess: 16});
      let floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI/2;
      floor.position.y = 0;
      floor.receiveShadow = true;
      scene.add(floor);
      objects.push(floor);

      // Walls (simple city block)
      for(let i=-40; i<=40; i+=20) {
        const wallGeo = new THREE.BoxGeometry(80, 7, 2);
        const wallMat = new THREE.MeshLambertMaterial({color: 0x23303a});
        let wall = new THREE.Mesh(wallGeo, wallMat);
        wall.position.set(0,3.5,i);
        scene.add(wall); objects.push(wall);
      }
      for(let i=-38; i<=38; i+=20) {
        const wallGeo = new THREE.BoxGeometry(2, 7, 76);
        const wallMat = new THREE.MeshLambertMaterial({color: 0x23303a});
        let wall = new THREE.Mesh(wallGeo, wallMat);
        wall.position.set(i,3.5,0);
        scene.add(wall); objects.push(wall);
      }

      // Simple buildings (boxes for theme)
      for(let i=0; i<7; ++i) {
        let bx = (Math.random()*60-30)|0, bz = (Math.random()*60-30)|0;
        if(Math.abs(bx)<9 && Math.abs(bz)<9) continue;
        let h = 4+Math.random()*10;
        let bGeo = new THREE.BoxGeometry(6+Math.random()*6, h, 6+Math.random()*6);
        let bMat = new THREE.MeshPhongMaterial({color:0x444c55, shininess: 36});
        let b = new THREE.Mesh(bGeo, bMat);
        b.position.set(bx, h/2, bz);
        scene.add(b); objects.push(b);
      }

      // Gun (simple cube in front of camera)
      const gunGeo = new THREE.BoxGeometry(0.25, 0.16, 1.1);
      const gunMat = new THREE.MeshPhongMaterial({color:0x222, shininess: 60});
      let gun = new THREE.Mesh(gunGeo, gunMat);
      gun.position.set(0.27, -0.21, -0.85);
      gun.castShadow = false;
      camera.add(gun);

      // Clock
      clock = new THREE.Clock();

      // Start the game loop
      animate();
    }

    // --- GAME LOOP ---
    function animate() {
      requestAnimationFrame(animate);
      let dt = Math.min(clock.getDelta(), 0.06);

      if(player.alive && pointerLocked) {
        updatePlayer(dt);
        updateEnemies(dt);
        updatePickups(dt);
        checkPickups();
        updateHUD();
      }

      renderer.render(scene, camera);
    }

    // --- PLAYER CONTROLS & MOVEMENT ---
    function updatePlayer(dt) {
      // Movement
      let speed = 6.1, friction = 0.75;
      let forward = controls.getDirection(new THREE.Vector3());
      let right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();
      let move = new THREE.Vector3();
      if(keys['w']||keys['ArrowUp']) move.add(forward);
      if(keys['s']||keys['ArrowDown']) move.add(forward.negate());
      if(keys['a']||keys['ArrowLeft']) move.add(right.negate());
      if(keys['d']||keys['ArrowRight']) move.add(right);

      if(move.length()>0) move.normalize();
      move.multiplyScalar(speed);

      // Gravity
      player.vel.y -= 22*dt;
      if(controls.getObject().position.y<=2) {
        player.vel.y = 0;
        controls.getObject().position.y = 2;
      }

      // Apply movement
      player.vel.x += move.x*dt*2.6;
      player.vel.z += move.z*dt*2.6;

      // Friction
      player.vel.x *= friction; player.vel.z *= friction;

      // Collision with walls/buildings
      let newPos = controls.getObject().position.clone().addScaledVector(player.vel, dt);
      for(let obj of objects) {
        if(obj.geometry instanceof THREE.BoxGeometry) {
          let b = obj;
          let w = b.scale.x*(b.geometry.parameters.width/2)||b.geometry.parameters.width/2;
          let h = b.scale.y*(b.geometry.parameters.height/2)||b.geometry.parameters.height/2;
          let d = b.scale.z*(b.geometry.parameters.depth/2)||b.geometry.parameters.depth/2;
          if(
            Math.abs(newPos.x-b.position.x)<w+0.6 &&
            Math.abs(newPos.y-b.position.y)<h+1.9 &&
            Math.abs(newPos.z-b.position.z)<d+0.6
          ) {
            player.vel.x = 0; player.vel.z = 0;
          }
        }
      }
      controls.getObject().position.addScaledVector(player.vel, dt);

      // Gun sway
      let gun = camera.children[0];
      let sway = 0.018*Math.sin(Date.now()/80)*(move.length()>0?1:0.4);
      gun.position.x = 0.27+sway;
      gun.position.y = -0.21+Math.abs(sway)*0.7;

      // Shooting
      if(mouseDown && !player.reloading && player.ammo>0 && performance.now()-player.lastShot>130) {
        shoot();
      }

      // Reload
      if(player.reloading) {
        reloadTimer += dt;
        if(reloadTimer>=player.reloadTime) {
          let needed = player.mag-player.ammo;
          let toLoad = Math.min(player.reserve, needed);
          player.ammo += toLoad;
          player.reserve -= toLoad;
          player.reloading = false;
          reloadTimer = 0;
        }
      }

      // Damage flash fade
      if(performance.now()-lastDamageTime < 300) {
        damageFlash.style.display = 'block';
      } else {
        damageFlash.style.display = 'none';
      }
    }

    // --- SHOOTING ---
    function shoot() {
      player.lastShot = performance.now();
      player.ammo--;
      // Play gunshot sound
      playSound('shoot');
      // Raycast
      let dir = controls.getDirection(new THREE.Vector3()).normalize();
      let ray = new THREE.Raycaster(camera.position, dir, 0, 30);
      let hits = [];
      for(let enemy of enemies) {
        if(!enemy.alive) continue;
        let dist = ray.ray.distanceToPoint(enemy.mesh.position);
        if(dist<1.5) {
          hits.push({enemy, dist});
        }
      }
      if(hits.length>0) {
        // Closest enemy hit
        hits.sort((a,b)=>a.dist-b.dist);
        let hit = hits[0].enemy;
        let headshot = Math.abs(hit.mesh.position.y+1.1 - camera.position.y)<1;
        let dmg = headshot? 80 : 36+Math.random()*7;
        hit.health -= dmg;
        spawnHitEffect(hit.mesh.position, headshot);
        playSound(headshot?'headshot':'hit');
        if(hit.health<=0 && hit.alive) {
          killEnemy(hit, headshot);
        }
      } else {
        // Miss: spawn bullet puff
        let pt = camera.position.clone().addScaledVector(dir, 16+Math.random()*8);
        spawnMissEffect(pt);
      }
      updateHUD();
    }

    function reload() {
      if(player.reloading || player.ammo===player.mag || player.reserve===0) return;
      playSound('reload');
      player.reloading = true;
      reloadTimer = 0;
    }

    // --- ENEMIES ---
    function spawnEnemy() {
      let px = 0, pz = 0;
      while(Math.abs(px)<10 && Math.abs(pz)<10) {
        px = Math.random()*60-30; pz = Math.random()*60-30;
      }
      let mesh = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.7, 1.8, 3, 8),
        new THREE.MeshPhongMaterial({color:0xa22, shininess: 10})
      );
      mesh.position.set(px, 2, pz);
      scene.add(mesh);

      let enemy = {
        mesh, health: 100, alive: true, speed: 3+Math.random()*0.7, attackCD: 0
      };
      enemies.push(enemy);
    }

    function updateEnemies(dt) {
      // Spawn new enemies
      if(enemies.length<level+2 && performance.now()>nextEnemySpawn) {
        spawnEnemy();
        nextEnemySpawn = performance.now()+1400+Math.random()*2200;
      }
      // Update AI
      for(let enemy of enemies) {
        if(!enemy.alive) continue;
        let toPlayer = controls.getObject().position.clone().sub(enemy.mesh.position);
        let dist = toPlayer.length();
        if(dist<1.6) {
          // Attack!
          enemy.attackCD -= dt;
          if(enemy.attackCD<=0) {
            damagePlayer(18+Math.random()*8);
            enemy.attackCD = 0.8+Math.random()*0.8;
            playSound('enemyHit');
          }
        } else {
          // Move toward player
          toPlayer.y = 0; toPlayer.normalize();
          enemy.mesh.position.addScaledVector(toPlayer, enemy.speed*dt);
          // Face player
          let ang = Math.atan2(toPlayer.x, toPlayer.z);
          enemy.mesh.rotation.y = ang;
        }
      }
    }

    function killEnemy(enemy, headshot) {
      enemy.alive = false;
      player.score += headshot? 120 : 70;
      // Spawn pickup
      if(Math.random()<0.7) {
        let type = Math.random()<0.6 ? 'ammo' : 'health';
        pickups.push({
          mesh: spawnPickup(enemy.mesh.position, type),
          type
        });
      }
      // Fade out
      let mesh = enemy.mesh;
      let fade = 1;
      let fadeOut = () => {
        fade -= 0.03;
        mesh.material.opacity = Math.max(fade, 0);
        mesh.material.transparent = true;
        if(fade>0) requestAnimationFrame(fadeOut);
        else scene.remove(mesh);
      }; fadeOut();
    }

    function damagePlayer(dmg) {
      player.health -= dmg;
      lastDamageTime = performance.now();
      playSound('damage');
      if(player.health<=0 && player.alive) gameOver();
    }

    // --- PICKUPS ---
    function spawnPickup(pos, type) {
      let geo, mat;
      if(type==='ammo') {
        geo = new THREE.BoxGeometry(0.7,0.5,1);
        mat = new THREE.MeshPhongMaterial({color:0x7cf, shininess:40, emissive:0x2244ff, emissiveIntensity:0.35});
      } else {
        geo = new THREE.DodecahedronGeometry(0.5,0);
        mat = new THREE.MeshPhongMaterial({color:0x3f5, shininess:40, emissive:0x33ff44, emissiveIntensity:0.35});
      }
      let mesh = new THREE.Mesh(geo, mat);
      mesh.position.copy(pos);
      mesh.position.y += 1.1;
      scene.add(mesh);
      return mesh;
    }

    function updatePickups(dt) {
      for(let p of pickups) {
        p.mesh.rotation.y += 0.06;
        p.mesh.position.y += Math.sin(Date.now()/420+p.mesh.position.x)*0.013;
      }
    }

    function checkPickups() {
      let ppos = controls.getObject().position;
      for(let i=pickups.length-1; i>=0; --i) {
        let p = pickups[i];
        if(p.mesh.position.distanceTo(ppos)<1.7) {
          if(p.type==='ammo') {
            let added = Math.min(player.mag*2-player.reserve, 30);
            player.reserve += added;
            showPickupMsg('+Ammo');
            playSound('pickup');
          } else if(p.type==='health') {
            let added = Math.min(player.maxHealth-player.health, 35);
            player.health += added;
            showPickupMsg('+Health');
            playSound('pickup');
          }
          scene.remove(p.mesh);
          pickups.splice(i,1);
        }
      }
    }

    function showPickupMsg(msg) {
      pickupMsg.style.display = 'block';
      pickupMsg.textContent = msg;
      pickupMsgTimer = 1.1;
      setTimeout(()=>{
        pickupMsg.style.display = 'none';
      }, 950);
    }

    // --- EFFECTS ---
    function spawnHitEffect(pos, headshot) {
      // Particle flash at pos
      let geo = new THREE.SphereGeometry(headshot?0.41:0.26, 6, 6);
      let mat = new THREE.MeshBasicMaterial({color:headshot?0xffff44:0xff2233, transparent:true, opacity:0.8});
      let mesh = new THREE.Mesh(geo, mat);
      mesh.position.copy(pos);
      scene.add(mesh);
      setTimeout(()=>scene.remove(mesh), 280);
    }
    function spawnMissEffect(pos) {
      let geo = new THREE.SphereGeometry(0.15, 5, 5);
      let mat = new THREE.MeshBasicMaterial({color:0xaabbe0, transparent:true, opacity:0.47});
      let mesh = new THREE.Mesh(geo, mat);
      mesh.position.copy(pos);
      scene.add(mesh);
      setTimeout(()=>scene.remove(mesh), 220);
    }

    // --- HUD/UI ---
    function updateHUD() {
      hudText.textContent = `Health: ${Math.max(0,player.health)}/${player.maxHealth}   Score: ${player.score}   Level: ${level}`;
      ammo.textContent = `Ammo: ${player.ammo} / ${player.reserve}`;
      if(player.reloading) ammo.textContent += " (reloading)";
    }

    // --- AUDIO ---
    const audioCTX = window.AudioContext ? new AudioContext() : null;
    function playSound(type) {
      if(!audioCTX) return;
      let o = audioCTX.createOscillator(),
          g = audioCTX.createGain();
      o.connect(g); g.connect(audioCTX.destination);
      if(type=='shoot') {
        o.type='square'; o.frequency.value=780; g.gain.value=0.21;
        o.frequency.setValueAtTime(780, audioCTX.currentTime);
        o.frequency.linearRampToValueAtTime(340, audioCTX.currentTime+0.13);
      } else if(type=='reload') {
        o.type='triangle'; o.frequency.value=360; g.gain.value=0.12;
        o.frequency.linearRampToValueAtTime(140, audioCTX.currentTime+0.22);
      } else if(type=='hit') {
        o.type='sawtooth'; o.frequency.value=390; g.gain.value=0.19;
        o.frequency.linearRampToValueAtTime(110, audioCTX.currentTime+0.09);
      } else if(type=='headshot') {
        o.type='square'; o.frequency.value=1020; g.gain.value=0.39;
        o.frequency.linearRampToValueAtTime(320, audioCTX.currentTime+0.16);
      } else if(type=='pickup') {
        o.type='triangle'; o.frequency.value=920; g.gain.value=0.18;
        o.frequency.linearRampToValueAtTime(340, audioCTX.currentTime+0.11);
      } else if(type=='damage') {
        o.type='triangle'; o.frequency.value=200; g.gain.value=0.26;
        o.frequency.linearRampToValueAtTime(60, audioCTX.currentTime+0.10);
      } else if(type=='enemyHit') {
        o.type='square'; o.frequency.value=180; g.gain.value=0.18;
        o.frequency.linearRampToValueAtTime(60, audioCTX.currentTime+0.07);
      }
      o.start();
      o.stop(audioCTX.currentTime+0.16);
    }

    // --- GAME OVER ---
    function gameOver() {
      player.alive = false;
      pointerLocked = false;
      controls.unlock();
      setTimeout(()=>{
        hud.style.display = 'none';
        gameover.style.display = 'block';
        gameover.innerHTML = `<div style="font-size:2.1em; color:#f66; margin-bottom:1em;">Game Over</div>
          <div style="color:#fff; font-size:1.2em; margin-bottom:1.5em;">
            Score: <b>${player.score}</b><br>
            Level: <b>${level}</b>
          </div>
          <button id="restartBtn">Restart</button>`;
        document.getElementById('restartBtn').onclick = restartGame;
      }, 600);
    }
    function restartGame() {
      // Reset all
      for(let e of enemies) scene.remove(e.mesh);
      for(let p of pickups) scene.remove(p.mesh);
      enemies = []; pickups = [];
      player.health = player.maxHealth;
      player.ammo = player.mag;
      player.reserve = 90;
      player.reloading = false;
      player.score = 0;
      player.alive = true;
      controls.getObject().position.set(0,2,0);
      pointerLocked = false; level = 1;
      gameover.style.display = 'none';
      hud.style.display = 'none';
      menu.style.display = 'flex';
    }

    // --- MENU / POINTER LOCK ---
    function startGame() {
      menu.style.display = 'none';
      hud.style.display = 'flex';
      pointerLocked = false;
      // Set up pointer lock
      renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock ||
        renderer.domElement.mozRequestPointerLock;
      renderer.domElement.requestPointerLock();
    }

    function handlePointerLock() {
      document.addEventListener('pointerlockchange', onPointerLockChange, false);
      document.addEventListener('mozpointerlockchange', onPointerLockChange, false);
      renderer.domElement.addEventListener('click', () => {
        if(!pointerLocked && menu.style.display==='none') {
          renderer.domElement.requestPointerLock();
        }
      });
    }
    function onPointerLockChange() {
      if(document.pointerLockElement===renderer.domElement ||
         document.mozPointerLockElement===renderer.domElement) {
        pointerLocked = true;
        controls.lock();
        hud.style.display = 'flex';
      } else {
        pointerLocked = false;
        controls.unlock();
        hud.style.display = 'none';
        if(player.alive) menu.style.display = 'flex';
      }
    }

    // --- LEVEL / SPAWNING ---
    function checkLevelProgress() {
      let alive = enemies.filter(e=>e.alive).length;
      if(alive==0 && player.alive) {
        setTimeout(()=>{
          level++;
          nextEnemySpawn = performance.now()+800;
        }, 700);
      }
    }
    setInterval(checkLevelProgress, 1100);

    // --- EVENT HANDLERS ---
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    startBtn.onclick = ()=>{
      startGame();
    };

    // Controls
    document.addEventListener('keydown', e=>{
      keys[e.key.toLowerCase()] = true;
      if(e.key==='r') reload();
      if(e.key==='Escape') { pointerLocked=false; controls.unlock(); }
    });
    document.addEventListener('keyup', e=>{
      keys[e.key.toLowerCase()] = false;
    });

    // These must be attached after renderer is created!
    function setupMouse() {
      renderer.domElement.addEventListener('mousedown', e=>{
        mouseDown = true;
      });
      renderer.domElement.addEventListener('mouseup', e=>{
        mouseDown = false;
      });
    }

    // Prevent scrolling
    window.addEventListener('keydown', function(e) {
      if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
        e.preventDefault();
      }
    }, false);

    // --- STARTUP ---
    window.onload = function() {
      if(window.innerWidth<900) {
        mobile.style.display = 'flex';
        return;
      }
      setup();
      setupMouse();
      handlePointerLock();
    };
  </script>
</body>
</html>
